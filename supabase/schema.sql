-- ============================================
-- DRSS DATABASE SCHEMA
-- Marketing Agency Operating System
-- ============================================
-- This schema supports all phases of the application:
-- Phase 1: clients, projects, content_assets
-- Phase 2: Multi-client views (all tables)
-- Phase 3: frameworks, framework_embeddings, ai_generations (RAG)
-- Phase 4: component_templates, pages, component_instances (page builder)
--
-- IMPORTANT: Run this AFTER enabling the vector extension in Supabase dashboard
-- ============================================

-- ============================================
-- ENABLE EXTENSIONS
-- ============================================
-- pgvector must be enabled manually in Supabase dashboard first:
-- 1. Go to Database â†’ Extensions
-- 2. Search for "vector"
-- 3. Enable "vector" extension
-- This line verifies it exists
CREATE EXTENSION IF NOT EXISTS vector;

-- ============================================
-- CLIENTS TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS clients (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  email TEXT,
  website TEXT,
  intake_responses JSONB,
  brand_data JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_clients_user_id ON clients(user_id);

-- ============================================
-- PROJECTS TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  status TEXT NOT NULL DEFAULT 'backlog',
  due_date DATE,
  priority TEXT DEFAULT 'medium',
  position INTEGER DEFAULT 0,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_projects_client_id ON projects(client_id);
CREATE INDEX IF NOT EXISTS idx_projects_status ON projects(status);
CREATE INDEX IF NOT EXISTS idx_projects_due_date ON projects(due_date);

-- ============================================
-- FRAMEWORKS TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS frameworks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  category TEXT,
  content TEXT NOT NULL,
  content_json JSONB,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_frameworks_user_id ON frameworks(user_id);
CREATE INDEX IF NOT EXISTS idx_frameworks_category ON frameworks(category);

-- ============================================
-- FRAMEWORK EMBEDDINGS TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS framework_embeddings (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  framework_id UUID REFERENCES frameworks(id) ON DELETE CASCADE NOT NULL,
  chunk_index INTEGER NOT NULL,
  content TEXT NOT NULL,
  embedding VECTOR(1536),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_framework_embeddings_framework_id ON framework_embeddings(framework_id);

-- ============================================
-- CONTENT ASSETS TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS content_assets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE NOT NULL,
  project_id UUID REFERENCES projects(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  asset_type TEXT NOT NULL,
  content_json JSONB,
  file_url TEXT,
  file_size INTEGER,
  file_type TEXT,
  metadata JSONB,
  version INTEGER DEFAULT 1,
  parent_id UUID REFERENCES content_assets(id) ON DELETE SET NULL,
  is_archived BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_content_assets_client_id ON content_assets(client_id);
CREATE INDEX IF NOT EXISTS idx_content_assets_project_id ON content_assets(project_id);
CREATE INDEX IF NOT EXISTS idx_content_assets_asset_type ON content_assets(asset_type);
CREATE INDEX IF NOT EXISTS idx_content_assets_parent_id ON content_assets(parent_id);

-- ============================================
-- COMPONENT TEMPLATES TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS component_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  display_name TEXT NOT NULL,
  category TEXT NOT NULL,
  description TEXT,
  structure JSONB NOT NULL,
  required_fields JSONB NOT NULL,
  preview_image TEXT,
  is_active BOOLEAN DEFAULT true,
  usage_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_component_templates_user_id ON component_templates(user_id);
CREATE INDEX IF NOT EXISTS idx_component_templates_category ON component_templates(category);

-- ============================================
-- PAGES TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS pages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  client_id UUID REFERENCES clients(id) ON DELETE CASCADE NOT NULL,
  project_id UUID REFERENCES projects(id) ON DELETE SET NULL,
  name TEXT NOT NULL,
  slug TEXT NOT NULL,
  page_type TEXT DEFAULT 'landing_page',
  meta_title TEXT,
  meta_description TEXT,
  is_published BOOLEAN DEFAULT false,
  published_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(client_id, slug)
);

CREATE INDEX IF NOT EXISTS idx_pages_client_id ON pages(client_id);
CREATE INDEX IF NOT EXISTS idx_pages_project_id ON pages(project_id);

-- ============================================
-- COMPONENT INSTANCES TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS component_instances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  page_id UUID REFERENCES pages(id) ON DELETE CASCADE NOT NULL,
  template_id UUID REFERENCES component_templates(id) NOT NULL,
  content_data JSONB NOT NULL,
  position INTEGER NOT NULL DEFAULT 0,
  is_visible BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_component_instances_page_id ON component_instances(page_id);
CREATE INDEX IF NOT EXISTS idx_component_instances_template_id ON component_instances(template_id);

-- ============================================
-- AI GENERATIONS TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS ai_generations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  client_id UUID REFERENCES clients(id) ON DELETE SET NULL,
  generation_type TEXT NOT NULL,
  prompt TEXT NOT NULL,
  context_used JSONB,
  model_used TEXT NOT NULL,
  tokens_used INTEGER,
  cost_estimate DECIMAL(10, 4),
  output_data JSONB,
  was_accepted BOOLEAN,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_ai_generations_user_id ON ai_generations(user_id);
CREATE INDEX IF NOT EXISTS idx_ai_generations_client_id ON ai_generations(client_id);
CREATE INDEX IF NOT EXISTS idx_ai_generations_created_at ON ai_generations(created_at);

-- ============================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================

-- Enable RLS on all tables
ALTER TABLE clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE frameworks ENABLE ROW LEVEL SECURITY;
ALTER TABLE framework_embeddings ENABLE ROW LEVEL SECURITY;
ALTER TABLE content_assets ENABLE ROW LEVEL SECURITY;
ALTER TABLE component_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE pages ENABLE ROW LEVEL SECURITY;
ALTER TABLE component_instances ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_generations ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist (for idempotency)
DROP POLICY IF EXISTS "Users can access their own clients" ON clients;
DROP POLICY IF EXISTS "Users can access projects for their clients" ON projects;
DROP POLICY IF EXISTS "Users can access their own frameworks" ON frameworks;
DROP POLICY IF EXISTS "Users can access embeddings for their frameworks" ON framework_embeddings;
DROP POLICY IF EXISTS "Users can access content for their clients" ON content_assets;
DROP POLICY IF EXISTS "Users can access their own templates" ON component_templates;
DROP POLICY IF EXISTS "Users can access pages for their clients" ON pages;
DROP POLICY IF EXISTS "Users can access component instances for their pages" ON component_instances;
DROP POLICY IF EXISTS "Users can access their own AI generations" ON ai_generations;

-- RLS Policies: Clients
CREATE POLICY "Users can access their own clients"
ON clients FOR ALL
USING (auth.uid() = user_id);

-- RLS Policies: Projects
CREATE POLICY "Users can access projects for their clients"
ON projects FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM clients 
    WHERE clients.id = projects.client_id 
    AND clients.user_id = auth.uid()
  )
);

-- RLS Policies: Frameworks
CREATE POLICY "Users can access their own frameworks"
ON frameworks FOR ALL
USING (auth.uid() = user_id);

-- RLS Policies: Framework Embeddings
CREATE POLICY "Users can access embeddings for their frameworks"
ON framework_embeddings FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM frameworks 
    WHERE frameworks.id = framework_embeddings.framework_id 
    AND frameworks.user_id = auth.uid()
  )
);

-- RLS Policies: Content Assets
CREATE POLICY "Users can access content for their clients"
ON content_assets FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM clients 
    WHERE clients.id = content_assets.client_id 
    AND clients.user_id = auth.uid()
  )
);

-- RLS Policies: Component Templates
CREATE POLICY "Users can access their own templates"
ON component_templates FOR ALL
USING (auth.uid() = user_id);

-- RLS Policies: Pages
CREATE POLICY "Users can access pages for their clients"
ON pages FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM clients 
    WHERE clients.id = pages.client_id 
    AND clients.user_id = auth.uid()
  )
);

-- RLS Policies: Component Instances
CREATE POLICY "Users can access component instances for their pages"
ON component_instances FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM pages 
    JOIN clients ON clients.id = pages.client_id
    WHERE pages.id = component_instances.page_id 
    AND clients.user_id = auth.uid()
  )
);

-- RLS Policies: AI Generations
CREATE POLICY "Users can access their own AI generations"
ON ai_generations FOR ALL
USING (auth.uid() = user_id);

-- ============================================
-- HELPER FUNCTIONS
-- ============================================

-- Function: Vector similarity search (for Phase 3 RAG)
CREATE OR REPLACE FUNCTION match_framework_chunks(
  query_embedding VECTOR(1536),
  match_threshold FLOAT,
  match_count INT
)
RETURNS TABLE (
  id BIGINT,
  framework_id UUID,
  content TEXT,
  similarity FLOAT
)
LANGUAGE SQL STABLE
AS $$
  SELECT
    framework_embeddings.id,
    framework_embeddings.framework_id,
    framework_embeddings.content,
    1 - (framework_embeddings.embedding <=> query_embedding) AS similarity
  FROM framework_embeddings
  WHERE 1 - (framework_embeddings.embedding <=> query_embedding) > match_threshold
  ORDER BY similarity DESC
  LIMIT match_count;
$$;

-- Function: Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers: Apply updated_at to relevant tables
DROP TRIGGER IF EXISTS update_clients_updated_at ON clients;
CREATE TRIGGER update_clients_updated_at 
  BEFORE UPDATE ON clients
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_projects_updated_at ON projects;
CREATE TRIGGER update_projects_updated_at 
  BEFORE UPDATE ON projects
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_frameworks_updated_at ON frameworks;
CREATE TRIGGER update_frameworks_updated_at 
  BEFORE UPDATE ON frameworks
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_content_assets_updated_at ON content_assets;
CREATE TRIGGER update_content_assets_updated_at 
  BEFORE UPDATE ON content_assets
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_component_templates_updated_at ON component_templates;
CREATE TRIGGER update_component_templates_updated_at 
  BEFORE UPDATE ON component_templates
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_pages_updated_at ON pages;
CREATE TRIGGER update_pages_updated_at 
  BEFORE UPDATE ON pages
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_component_instances_updated_at ON component_instances;
CREATE TRIGGER update_component_instances_updated_at 
  BEFORE UPDATE ON component_instances
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

